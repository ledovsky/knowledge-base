# Numpy cookbook

## Краткое описание

Библиотека, реализующая быстроработющий многомерный массив в Python. Лежит в основе большого количества других вычислительных библиотек. Написан на C.

## Типы данных

Основные типы данных:

* bool_
* int_ (64 или 32)
* float_ (64)
* complex_ (128)

Типы можно указывать в аргументе dtype несколькими способами

* Рекомендованный - `np.int_`
* Из старых версий - `int`
* Из старых версий - `'i'`

## Создание массива

    :::python
    # Из списков
    np.array([[1, 2], [3, 4]])
    np.array([[1, 2], [3, 4]], dtype=np.int_)

    numpy.arange(2500).reshape(50, 50)  # Тестовая матрица
    
    # Пустые массивы
    np.empty([2, 2])                    # Пустой массив
    np.empty([2, 2], dtype=np.int_)     # Пустой массив типа int_
    
    #  Случайные массивы
    np.random.rand(d0,d1..,dn)          # Случайный, равномерораспред. [0; 1]
    np.random.randn(d0,d1..,dn)         # Случайный, станд. норм. распред.
    np.random.randint(3, size=10)       # Случайный, целые числа (0, 1, 2)
    
    # Сетки и линейные пространства
    np.linspace(start, stop, num=num)   # Используется для мат. вычислений
    np.meshgrid(x,y)                    # Сетка из массивов x и y


Если тип данных не указан, то берется наименьший необходимый. Т.е. тип данных имеет смысл указывать, когда необходимо восходящее преобразование типов (upcast). Для низходящего преобразования используется метод `.astype(t)`

В данных функциях также можно добавить `dtype`:

## Базовые операции с массивами

### Выбор подмассива

    :::python
    X[:,1]
    X[:5, 1]                    # По 1-й координате выбираются индексы [0;4]
    X[5:, 1]                    # По 1-й координате выбираются индексы [5;n-1]

### Изменение формы: .reshape(), .ravel()

Одна из ключевых функций для манипуляций над массивом.

* `-1` в аргументе означает, что алгоритм сам рассчитает необохдимый размер массива для заданной размерности
* Порядок обхода элементов меняется аргументом `order`. По умолчанию равен `'C'` - C-style. Обход начинается с первой оси, т.е. со строк для матрицы, или с axis=0
* Можно задать `order='F'` - Fortran-style. Обход начинается с последней оси, т.е. со столбцов для матрицы или axis=max

Сведение к одномерному массиву. 

    :::python 
    a = np.array([[1, 2], [3, 4]])
    
    a.reshape(-1)
    # array([1, 2, 3, 4])
    
    a.ravel()  # то же самое
    # array([1, 2, 3, 4])
    
    a.reshape(-1, order='F')
    # array([1, 3, 2, 4])

Другие примеры изменения формы

    :::python
    a = np.arange(12).reshape(2, 2, 3) # 1-d массив преобразуем в 3-d
    # array([[[ 0,  1,  2], [ 3,  4,  5]], [[ 6,  7,  8], [ 9, 10, 11]]])
    
    # Преобразуем в матрицу 2х6
    a.reshape(2, 6)
    # array([[ 0,  1,  2,  3,  4,  5], [ 6,  7,  8,  9, 10, 11]])
    
    a.reshape(2, -1)  # Идентичный результат, -1 - автоопределение размерности 
    # array([[ 0,  1,  2,  3,  4,  5], [ 6,  7,  8,  9, 10, 11]])

### Объединение массивов

На мой взгляд предпочтительнее hstack и vstack из-за лучшей читабельности

    :::python
    # Вертикальное объединение - 2 варианта
    np.concatenate([a1, a2], axis=0) 
    np.vstack((a1, a2))
    
    # Горизонтальное объединение - 2 варианта
    np.concatenate([a1, a2], axis=1) 
    np.hstack((a1, a2))

## Цикл по массиву

Не рекомендуется в явном виде использовать цикл по массиву. Вместо этого рекомендуется использовать векторизированные функции. В крайнем случае, можно использовать обычный цикл for:

    :::python
    for i in range(a.shape[0]):
        for j in range(a.shape[1]):
            print a[i,j]

В Numpy также присутстует функция итератора np.nditer. Она позволяет эффективно пройтись по всем элементам массива. На данный момент не применял ее. ![Документация](http://docs.scipy.org/doc/numpy/reference/arrays.nditer.html)

## Применение функций

### Встроенные математические функции

    :::python
    np.sum(a)                   # Сумма всех элементов
    np.sum(a, axis=1)           # Сумма по 0-й оси координат
    np.sum(a, axis=(0,1))       # Сумма по 0-й и 1-й оси координат
    np.power(a, 5)              # Возведение в степерь
    
    a1 + a2
    a1 - a2
    a1 * a2
    a1 / a2
    
    np.mean(a)                 
    np.std(a)
    
    np.round(a)

Прочие математические функции:
http://docs.scipy.org/doc/numpy/reference/routines.math.html

###  Применить функцию ко всем элементам - vectorize(f)

В Numpy нет функции `map`. Для того, чтобы применить функцию к каждому элементу массива используется векторизация функции - `vectorize`. Она принимает базовую функцию, возвращает векторизированную, которую можно применить сразу к массивам и получить на выходе массив-результат такой же размерности.

    :::python
    # Один массив
    
    def f(x):
        return x * x + 1
    
    fv = np.vectorize(f)
    a = np.array([1, 2, 3])
    fv(a)
    # array([ 2,  5, 10 ])
    
    # Два массива
    
    def f(a, b):
        if a > b:
            return a * b
        else:
            return a / float(b)
    
    a1 = np.array([1, 3, 5])
    a2 = np.array([2, 3, 4])
    fv = np.vectorize(f)
    fv(a1, a2)
    # array([ 0.5, 1., 20. ])

### Применить функцию по оси/осям - apply_along_axis и apply_over_axis

Используются, чтобы отправить в функцию подмассивы, например строки или стобцы. apply_over_axis более универсальна, т.к. может выдать массивы сразу по нескольким осям.

    :::python
    a = array([[[ 0,  1,  2],[ 3,  4,  5]],[[ 6,  7,  8],[ 9, 10, 11]]]
    # Идентичные записи
    np.apply_along_axis(np.sum, 0, a)
    np.apply_over_axes(np.sum, a, [0])
    # array([[[ 6,  8, 10], [12, 14, 16]]])
    
    # На несколько осей
    np.apply_over_axes(np.sum, a, [0, 1])
    # array([18, 22, 26])

[Ссылка на документацию - apply_over_axis](http://docs.scipy.org/doc/numpy-1.10.1/reference/generated/numpy.apply_over_axes.html)

## Сортировка

Примеры 

    :::python
    np.sort(a)          # Возвращает отсортированную копию массива a
    np.sort(a)[::-1]    # По убыванию
    np.argsort(a)       # Возвращает индексы отсортированного массива



Алгоритмы могут задаваться параметром `kind`

    :::python
    kind={‘quicksort’, ‘mergesort’, ‘heapsort’}


