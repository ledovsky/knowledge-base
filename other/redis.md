# Использование Redis

## Краткое описание и принцип работы

Redis - in-memory хранилище структур данных с открытым исходным кодом. Запись и доступ к структурам осуществляется по ключу. Структуры данных включают строки, хеши (аналог словарей), списки, множества и ряд других более специфичных структур.

Redis функционирует по принципу клиент-сервер. Сервер поднимается на внешней или локальной машине. Клиент подключается к серверу через ip (для локальной машины localhost) и порт (6379 по умолчанию). Для работы с сервером используются команды, например `SET key value`. Клиенты реализованы для языков программирования в виде интерфейса. В Python это специальный класс с методами, повторяющими названия команд. 

**Ограничение по памяти**. Redis работает in-memory. Это значит, что его размер не может превысить размер свободной оперативной памяти.

## Установка и настройка

### Установка

    :::python
    sudo apt-get install redis  # Linux
    brew install redis # Mac
    
    pip install redis  # клиент python

### Конфигурация

**Для начальной работы конфигурация не нужна**

Redis может запускаться с или без файла конфигурации. Также он спокойно конфигурируется в процессе работы. Запуск сервера с конфигурационным файлом

    :::python
    ./redis-server /path/to/redis.conf

Вид конфигурационного файла

    :::python
    maxmemory 2mb

Конфигурация через python

    :::python
    import redis
    r = redis.StrictRedis(host='localhost', port=6379, db=0)
    r.config_set('maxmemory', '2mb')

### Устойчивость

Redis сохраняет копии данных на жесткий диск. Он использует два способа. RDB - сохранение снимка базы данных и AOF (append-only file) - запись каждой операции. 

* RDB работает быстрее, и данные занимают меньше памяти на жестком диске, однако такие снимки делаются раз в некоторое время и в случае аварии последние записи могут потеряться
* AOF работает медленнее и занимает время, однако точно восстанавливает данные

Разработчики рекомендуют совмещать RDB и AOF. Также, при необходимости, устойчивость может быть отключена.

Настрока переодического сохранения RDB через конфигурацию конфигурации. Пример: сохранять (асинхронно) каждые 60 секунд при изменении 1000 ключей

    :::python
    SAVE 60 1000
    r.config_set('save', '60 1000')

Сохранение в явном виде. `save` - блокирует остальные запросы. `bgsave`, background save, работает асинхронно.

    :::python
    r.save()
    r.bgsave()

Настройка AOF

    :::python
    appendonly yes
    r.config_set('appendonly', 'yes')


## Простое key-value хранилище

    :::python
    import redis
    r = redis.StrictRedis(host='localhost', port=6379, db=0)
    r.set('key','value')
    print r.get('key')

Особенность value в том, что это строки. Т.е. если отправить в redis число типа float, то он запишет строку его в виде длинной строки. Соответственно, когда число будет доставаться обратно, его нужно будет конвертировать 

    :::python
    float(r.get('key'))

## Использование хешей для хранение объектов

Хеши в redis - тип данных, вроде словаря в python. Т.е. вместо простого key-value, хеш реализует структуру name-key-value.

    :::python
    r.hset(name, key, value)

В хешах предлагается хранить объекты данных, например данные о пользователе. Но в качестве полноценной базы данных redis нужно использовать осторожно, в связи с ограничением памяти.

## Уменьшение использования памяти с помощью хешей

Хеши рекомендуют использовать благодаря компактному хранению данных. Ключи в структуре хешируются, т.е. кодируются. При этом их место уменьшается, но тратится дополнительное время на кодирование/декодирование. В техническом блоге Instagram инженеры использовали хеши для минимизации затрат памяти на хранение большого key-value массива. Key-value пары разбивались на чанки и кодировались в хеши. 

    :::python
    for i in range(0, NUM_ENTRIES):
        value = random.randint(0, MAX_VAL)
        bucket = int(i / 500)
        r.hset(bucket, i, value)

При этом по их опыту оптимальный баланс между сжатием и загрузкой процессора лежит на пороге около 1000 пар в чанке.

[Статья](http://instagram-engineering.tumblr.com/post/12202313862/storing-hundreds-of-millions-of-simple-key-value)

[Гист](https://gist.github.com/mikeyk/1329319)

## Реализация очереди с помощью списков

В решениях для реализации очереди стандартом является RabbitMQ. Однако, это довольно сложный инструмент. Он содержит огромное число возможностей, которые не пригодятся в реализации типовой задачи, где нужно просто ассинхронно выполнять задачи. При этом RabbitMQ трудно устанавливать, настраивать и администрировать.

Минималистичной альтернативой является Redis. С помощью списков можно легко реализовать очередь. Список в redis - связанная последовательность элементов. В нее можно добавлять или забирать элементы с правой или левой стороны. Таким образом, с помощью списков легко делать буферы.

    :::python
    r.rpush(queue_name, item)   # put item
    r.lpop(queue_name)          # get item
    r.llen(queue_name)          # get queue length

Можно написать свой класс, как например в этой статье. [Статья](http://peter-hoffmann.com/2012/python-simple-queue-redis-queue.html)

[Статья: Сравнение Redis с RabbitMQ (с тестами)](http://www.minvolai.com/blog/2013/10/RabbitMQ-vs-Redis-as-Message-Brokers/rabbitmq-vs-redis-message-broker/)
